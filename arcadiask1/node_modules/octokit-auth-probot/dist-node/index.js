'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var authUnauthenticated = require('@octokit/auth-unauthenticated');
var authToken = require('@octokit/auth-token');
var authApp = require('@octokit/auth-app');

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

async function auth(state, options) {
  // return authentication from internal auth instance unless the event is "event-octokit"
  if (options.type !== "event-octokit") {
    if (state.type === "token" && options.type === "installation" && options.factory) {
      const {
        type,
        factory
      } = options,
            factoryAuthOptions = _objectWithoutProperties(options, ["type", "factory"]);

      return factory( // @ts-ignore factory options differ if internal auth type is token
      Object.assign({}, factoryAuthOptions, {
        octokit: state.octokit,
        octokitOptions: state.octokitOptions
      }));
    }

    return state.auth(options);
  } // unless the internal event type is "app", return the octokit
  // instance passed as strategy option


  if (state.type !== "app") {
    return state.octokit;
  }

  const action = options.event.payload.action;
  const installationId = options.event.payload.installation && options.event.payload.installation.id;
  const fullEventName = options.event.name + (action ? "." + action : "");
  const OctokitWithEventAuth = state.octokit.constructor;

  if (!installationId) {
    const _state$octokitOptions = state.octokitOptions,
          octokitOptions = _objectWithoutProperties(_state$octokitOptions, ["auth"]);

    return new OctokitWithEventAuth(_objectSpread2({
      authStrategy: authUnauthenticated.createUnauthenticatedAuth,
      auth: {
        reason: `Handling a "${fullEventName}" event: an "installation" key is missing. The installation ID cannot be determined`
      }
    }, octokitOptions));
  }

  if (options.event.name === "installation" && ["suspend", "deleted"].includes(String(action))) {
    const _state$octokitOptions2 = state.octokitOptions,
          octokitOptions = _objectWithoutProperties(_state$octokitOptions2, ["auth"]);

    return new OctokitWithEventAuth(_objectSpread2({
      authStrategy: authUnauthenticated.createUnauthenticatedAuth,
      auth: {
        reason: `Handling a "${fullEventName}" event: The app's access has been revoked from @octokit (id: ${installationId})`
      }
    }, octokitOptions));
  } // otherwise create a pre-authenticated (or unauthenticated) Octokit instance
  // depending on the event payload


  return state.auth({
    type: "installation",
    installationId,
    factory: auth => {
      const options = Object.assign({}, state.octokitOptions, {
        auth: Object.assign({}, auth, {
          installationId
        })
      });
      return new OctokitWithEventAuth(options);
    }
  });
}

function getState(options) {
  const common = {
    octokit: options.octokit,
    octokitOptions: options.octokitOptions
  };

  if ("token" in options) {
    return _objectSpread2({
      type: "token",
      auth: authToken.createTokenAuth(String(options.token))
    }, common);
  }

  if ("appId" in options && "privateKey" in options) {
    return _objectSpread2({
      type: "app",
      auth: authApp.createAppAuth(options)
    }, common);
  }

  return _objectSpread2({
    type: "unauthenticated",
    auth: authUnauthenticated.createUnauthenticatedAuth({
      reason: `Neither "appId"/"privateKey" nor "token" have been set as auth options`
    })
  }, common);
}

const VERSION = "0.0.0-development";

function createProbotAuth(options) {
  const state = getState(options);
  return Object.assign(auth.bind(null, state), {
    hook: state.auth.hook
  });
}
createProbotAuth.VERSION = VERSION;

exports.createProbotAuth = createProbotAuth;
//# sourceMappingURL=index.js.map
